import os
from image_genetic_problem import ImagePaletteGeneticProblem, ImagePaletteGeneticProblemRGBDistance
from image_genetic_problem_restricted import ImagePaletteGeneticProblemRestricted
from helper import (
    plot_fitness_evolution
)

def run_image_quantization(image_name, num_colors=10, restricted=False, 
                          population_size=20, generations=50, mutation_rate=0.2, 
                          crossover_rate=0.8, elitism=2, selection_method='tournament', 
                          tournament_size=3, adaptation_rate=1.2, adaptation_threshold=10, 
                          halting_stagnation_threshold=20, kMeans=False, 
                          mutate_diverse=False, crossover_method='one_point', 
                          save_results=True, display=True, rgb_distance=False, 
                          use_caching=True, output_dir=None):
    """
    Run the genetic algorithm for image quantization.

    Args:
        image_name (str): Name of the image file to process, must include the file extension (e.g., 'image.jpg') and be in the images folder.
        num_colors (int): Number of colors in the palette.
        restricted (bool): Whether to use a only colors in the original image color palette.
        population_size (int): Size of the population for the genetic algorithm.
        generations (int): Number of generations to run the genetic algorithm.
        mutation_rate (float): Probability of mutation for each color in the palette.
        crossover_rate (float): Probability of crossover between two parents.
        elitism (int): Number of best individuals to carry over to the next generation.
        selection_method (str): Selection method to use ('roulette', 'tournament', 'rank').
        tournament_size (int): Size of the tournament for tournament selection.
        adaptation_rate (float): Rate of adaptation for the genetic algorithm (if 1, no adaptation).
        adaptation_threshold (int): Threshold for adaptation.
        halting_stagnation_threshold (int): Threshold for halting due to stagnation.
        kMeans (bool): Whether to include a KMeans created example for initial population generation.
        mutate_diverse (bool): Whether to use diverse mutation or swapping mutation.
        crossover_method (str): Method of crossover to use ('one_point', 'uniform', 'closest_pairs').
        save_results (bool): Whether to save the results of the genetic algorithm.
        display (bool): Whether to display the results.
        rgb_distance (bool): Whether to use RGB distance for fitness calculation. It is recommended to use LAB color space for better results. If active,the algorithm will run in the unrestricted version.
        use_caching (bool): Whether to use caching for the image processing. If True, the image will be cached to avoid reprocessing.
        output_dir (str, optional): Directory where results should be saved. If None, results are saved in the default location.

    Returns:
            best_palette (list): The best palette found by the genetic algorithm.
            best_fitness (float): The fitness of the best palette.
            fitness_history (list): History of fitness values over generations.
            bestImage (PIL.Image): The image with the best palette applied.
            kMeans_palette (list): The palette generated by KMeans clustering if kMeans = True.
            kMeans_image (PIL.Image): The image with the KMeans palette applied if kMeans = True.
            performance_log (list): Detailed performance metrics for each generation of the algorithm.
    """

    image_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "images", image_name)

    # Create and run the genetic algorithm
    if rgb_distance:
        problem = ImagePaletteGeneticProblemRGBDistance(
            image_path, num_colors, kMeans=kMeans, 
            mutate_diverse=mutate_diverse, crossover_method=crossover_method, 
            save_results=save_results, display=display, use_caching=use_caching,
            results_dir=output_dir
        )
    elif not restricted:
        problem = ImagePaletteGeneticProblem(
            image_path, num_colors, kMeans=kMeans, 
            mutate_diverse=mutate_diverse, crossover_method=crossover_method, 
            save_results=save_results, display=display, use_caching=use_caching,
            results_dir=output_dir
        )
    else:
        problem = ImagePaletteGeneticProblemRestricted(
            image_path, num_colors, kMeans=kMeans, 
            mutate_diverse=mutate_diverse, crossover_method=crossover_method, 
            save_results=save_results, display=display, use_caching=use_caching,
            results_dir=output_dir
        )
    
    best_palette, best_fitness, fitness_history, average_fitness_history, bestImage, kMeans_palette, kMeans_image, performance_log = problem.run(
        population_size=population_size,
        generations=generations,
        mutation_rate=mutation_rate,
        crossover_rate=crossover_rate,
        elitism=elitism,
        selection_method=selection_method,
        tournament_size=tournament_size,
        adaptation_rate=adaptation_rate,
        adaptation_threshold=adaptation_threshold, 
        halting_stagnation_threshold=halting_stagnation_threshold,
    )
    
    print("\nGenetic algorithm completed.")
    print(f"Best palette: {best_palette}")
    print(f"Best palette fitness: {best_fitness:.6f}")

    plot_fitness_evolution(fitness_history, save_path=problem.results_dir, display=display)

    return best_palette, best_fitness, fitness_history, average_fitness_history, bestImage, kMeans_palette, kMeans_image, performance_log

if __name__ == "__main__":
    image_name = "cat.jpg" # Example image name, must be in the images folder
    num_colors = 32 # Number of colors in the palette
    
    restricted = True # Whether to use a only colors in the original image color palette
    
    population_size = 20 # Size of the population for the genetic algorithm
    generations = 30 # Number of generations to run the genetic algorithm
    
    selection_method = 'tournament' # Selection method to use ('roulette', 'tournament', 'rank')
    tournament_size = 3 # Size of the tournament for tournament selection
    mutate_diverse = True # Whether to use diverse mutation or swapping mutation
    crossover_method = 'closest_pairs' # Method of crossover to use ('one_point', 'uniform', 'closest_pairs')

    mutation_rate = 0.2 # Probability of mutation for each color in the palette
    crossover_rate = 0.8 # Probability of crossover between two parents
    elitism = 2 # Number of best individuals to carry over to the next generation

    adaptation_rate = 1.2 # Rate of adaptation for the genetic algorithm (if 1, no adaptation)
    adaptation_threshold = 10 # Threshold for adaptation
    halting_stagnation_threshold = 20 # Threshold for halting due to stagnation
    
    kMeans = False # Whether to include a KMeans created example for initial population generation

    save_results = True # Whether to save the results of the genetic algorithm
    display = True # Whether to display the results

    run_image_quantization(image_name, num_colors, restricted, population_size, generations, mutation_rate, crossover_rate, elitism, selection_method, tournament_size, adaptation_rate=adaptation_rate, adaptation_threshold=adaptation_threshold, halting_stagnation_threshold=halting_stagnation_threshold, kMeans=kMeans, mutate_diverse=mutate_diverse, crossover_method=crossover_method, save_results=save_results, display=display)